function t(t,n){let e=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:75;if(0===t.length)return"";const y=t.shift(),u=t[t.length-1];return(e?`M${y.x} ${o-y.x+2} L${y.x} ${y.y}`:`M${y.x} ${y.y}`)+t.map(((e,o)=>{const u=t[o+1],i=t[o-1]||y,h=u&&r(u,e,i);if(!u||h)return`L${e.x} ${e.y}`;const c=Math.min(x(i,e),x(u,e)),f=c/2<n?c/2:n,s=$(i,e,f),a=$(u,e,f);return`L${s.x} ${s.y}S${e.x} ${e.y} ${a.x} ${a.y}`})).join("")+(e?`L${u.x} ${o-y.x+2} Z`:"")}function n(t){return parseInt(t,10)}function r(t,r,x){return n(t.x+x.x)===n(2*r.x)&&n(t.y+x.y)===n(2*r.y)}function x(t,n){return Math.sqrt(Math.pow(n.x-t.x,2)+Math.pow(n.y-t.y,2))}function $(t,n,r){const x=t.x-n.x,$=t.y-n.y,e=Math.sqrt(x*x+$*$),o=x/e,y=$/e;return{x:n.x+o*r,y:n.y+y*r}}export{r as checkCollinear,t as genPath,x as getDistance,$ as moveTo};
