import{useId as e,computed as t,ref as l,watch as n,nextTick as a,createVNode as o}from"/Users/alexandarvalov/Documents/GitHub/nzis-import-app/node_modules/vue/index.mjs";import{makeLineProps as r}from"./util/line.mjs";import{genPath as i}from"./util/path.mjs";import{propsFactory as s}from"../../util/propsFactory.mjs";import{genericComponent as u}from"../../util/defineComponent.mjs";import{getPropertyFromItem as m}from"../../util/helpers.mjs";import{useRender as d}from"../../util/useRender.mjs";const f=s({fill:Boolean,...r()},"VTrendline"),p=u()({name:"VTrendline",props:f(),setup(r,s){let{slots:u}=s;const f=e(),p=t((()=>r.id||`trendline-${f}`)),c=t((()=>Number(r.autoDrawDuration)||(r.fill?500:2e3))),h=l(0),v=l(null);function g(e,t){const{minX:l,maxX:n,minY:a,maxY:o}=t,i=e.length,s=null!=r.max?Number(r.max):Math.max(...e),u=null!=r.min?Number(r.min):Math.min(...e),m=(n-l)/(i-1),d=(o-a)/(s-u||1);return e.map(((e,t)=>({x:l+t*m,y:o-(e-u)*d,value:e})))}const b=t((()=>Boolean(r.showLabels||r.labels.length>0||!!(null==u?void 0:u.label)))),x=t((()=>parseFloat(r.lineWidth)||4)),y=t((()=>Number(r.width))),D=t((()=>{const e=Number(r.padding);return{minX:e,maxX:y.value-e,minY:e,maxY:parseInt(r.height,10)-e}})),k=t((()=>r.modelValue.map((e=>m(e,r.itemValue,e))))),$=t((()=>{const e=[],t=g(k.value,D.value),l=t.length;for(let n=0;e.length<l;n++){const l=t[n];let a=r.labels[n];a||(a="object"==typeof l?l.value:l),e.push({x:l.x,value:String(a)})}return e}));function j(e){const t="boolean"==typeof r.smooth?r.smooth?8:0:Number(r.smooth);return i(g(k.value,D.value),t,e,parseInt(r.height,10))}n((()=>r.modelValue),(async()=>{if(await a(),!r.autoDraw||!v.value)return;const e=v.value,t=e.getTotalLength();r.fill?(e.style.transformOrigin="bottom center",e.style.transition="none",e.style.transform="scaleY(0)",e.getBoundingClientRect(),e.style.transition=`transform ${c.value}ms ${r.autoDrawEasing}`,e.style.transform="scaleY(1)"):(e.style.strokeDasharray=`${t}`,e.style.strokeDashoffset=`${t}`,e.getBoundingClientRect(),e.style.transition=`stroke-dashoffset ${c.value}ms ${r.autoDrawEasing}`,e.style.strokeDashoffset="0"),h.value=t}),{immediate:!0}),d((()=>{var e;const t=r.gradient.slice().length?r.gradient.slice().reverse():[""];return o("svg",{display:"block","stroke-width":parseFloat(r.lineWidth)??4},[o("defs",null,[o("linearGradient",{id:p.value,gradientUnits:"userSpaceOnUse",x1:"left"===r.gradientDirection?"100%":"0",y1:"top"===r.gradientDirection?"100%":"0",x2:"right"===r.gradientDirection?"100%":"0",y2:"bottom"===r.gradientDirection?"100%":"0"},[t.map(((e,l)=>o("stop",{offset:l/Math.max(t.length-1,1),"stop-color":e||"currentColor"},null)))])]),b.value&&o("g",{key:"labels",style:{textAnchor:"middle",dominantBaseline:"mathematical",fill:"currentColor"}},[$.value.map(((e,t)=>{var l;return o("text",{x:e.x+x.value/2+x.value/2,y:parseInt(r.height,10)-4+(parseInt(r.labelSize,10)||5.25),"font-size":Number(r.labelSize)||7},[(null==(l=u.label)?void 0:l.call(u,{index:t,value:e.value}))??e.value])}))]),o("path",{ref:v,d:j(r.fill),fill:r.fill?`url(#${p.value})`:"none",stroke:r.fill?"none":`url(#${p.value})`},null),r.fill&&o("path",{d:j(!1),fill:"none",stroke:r.color??(null==(e=r.gradient)?void 0:e[0])},null)])}))}});export{p as VTrendline,f as makeVTrendlineProps};
