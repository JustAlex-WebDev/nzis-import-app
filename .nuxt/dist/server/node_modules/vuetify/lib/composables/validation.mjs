import{makeFocusProps as e}from"./focus.mjs";import{useForm as a}from"./form.mjs";import{useProxiedModel as l}from"./proxiedModel.mjs";import{useToggleScope as r}from"./toggleScope.mjs";import{useId as t,computed as n,ref as u,shallowRef as i,unref as o,watch as s,nextTick as v}from"/Users/alexandarvalov/Documents/GitHub/nzis-import-app/node_modules/vue/index.mjs";import{propsFactory as d}from"../util/propsFactory.mjs";import{getCurrentInstanceName as m,getCurrentInstance as p}from"../util/getCurrentInstance.mjs";import{wrapInArray as g}from"../util/helpers.mjs";const f=d({disabled:{type:Boolean,default:null},error:Boolean,errorMessages:{type:[Array,String],default:()=>[]},maxErrors:{type:[Number,String],default:1},name:String,label:String,readonly:{type:Boolean,default:null},rules:{type:Array,default:()=>[]},modelValue:null,validateOn:String,validationValue:null,...e()},"validation");function c(e){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:m(),f=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t();const c=l(e,"modelValue"),y=n((()=>void 0===e.validationValue?c.value:e.validationValue)),h=a(e),b=u([]),j=i(!0),x=n((()=>!(!g(""===c.value?null:c.value).length&&!g(""===y.value?null:y.value).length))),V=n((()=>{var a;return(null==(a=e.errorMessages)?void 0:a.length)?g(e.errorMessages).concat(b.value).slice(0,Math.max(0,Number(e.maxErrors))):b.value})),z=n((()=>{var a;let l=(e.validateOn??(null==(a=h.validateOn)?void 0:a.value))||"input";"lazy"===l&&(l="input lazy"),"eager"===l&&(l="input eager");const r=new Set((null==l?void 0:l.split(" "))??[]);return{input:r.has("input"),blur:r.has("blur")||r.has("input")||r.has("invalid-input"),invalidInput:r.has("invalid-input"),lazy:r.has("lazy"),eager:r.has("eager")}})),M=n((()=>{var a;return!e.error&&!(null==(a=e.errorMessages)?void 0:a.length)&&(!e.rules.length||(j.value?!b.value.length&&!z.value.lazy||null:!b.value.length))})),S=i(!1),w=n((()=>({[`${d}--error`]:!1===M.value,[`${d}--dirty`]:x.value,[`${d}--disabled`]:h.isDisabled.value,[`${d}--readonly`]:h.isReadonly.value})));p("validation");const D=n((()=>e.name??o(f)));async function $(){j.value=!0,z.value.lazy?b.value=[]:await R(!z.value.eager)}async function R(){let a=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const l=[];S.value=!0;for(const r of e.rules){if(l.length>=Number(e.maxErrors??1))break;const a="function"==typeof r?r:()=>r,t=await a(y.value);!0!==t&&(!1===t||"string"==typeof t?l.push(t||""):console.warn(`${t} is not a valid value. Rule functions must return boolean true or a string.`))}return b.value=l,S.value=!1,j.value=a,b.value}return r((()=>z.value.input||z.value.invalidInput&&!1===M.value),(()=>{s(y,(()=>{if(null!=y.value)R();else if(e.focused){const a=s((()=>e.focused),(e=>{e||R(),a()}))}}))})),r((()=>z.value.blur),(()=>{s((()=>e.focused),(e=>{e||R()}))})),s([M,V],(()=>{var e;null==(e=h.update)||e.call(h,D.value,M.value,V.value)})),{errorMessages:V,isDirty:x,isDisabled:h.isDisabled,isReadonly:h.isReadonly,isPristine:j,isValid:M,isValidating:S,reset:async function(){c.value=null,await v(),await $()},resetValidation:$,validate:R,validationClasses:w}}export{f as makeValidationProps,c as useValidation};
