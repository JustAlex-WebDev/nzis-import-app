import{useProxiedModel as e}from"../proxiedModel.mjs";import{ref as t,computed as a,toRef as n,shallowRef as l,provide as r,inject as o,toRaw as u}from"/Users/alexandarvalov/Documents/GitHub/nzis-import-app/node_modules/vue/index.mjs";import{independentSingleActiveStrategy as i,independentActiveStrategy as s,leafSingleActiveStrategy as c,leafActiveStrategy as v}from"./activeStrategies.mjs";import{multipleOpenStrategy as d,singleOpenStrategy as p,listOpenStrategy as m}from"./openStrategies.mjs";import{classicSelectStrategy as f,trunkSelectStrategy as g,independentSingleSelectStrategy as S,independentSelectStrategy as y,leafSelectStrategy as h,leafSingleSelectStrategy as b}from"./selectStrategies.mjs";import{propsFactory as w}from"../../util/propsFactory.mjs";import{getCurrentInstance as j}from"../../util/getCurrentInstance.mjs";import{consoleError as M}from"../../util/console.mjs";const O=Symbol.for("vuetify:nested"),k={id:l(),root:{register:()=>null,unregister:()=>null,parents:t(new Map),children:t(new Map),open:()=>null,openOnSelect:()=>null,activate:()=>null,select:()=>null,activatable:t(!1),selectable:t(!1),opened:t(new Set),activated:t(new Set),selected:t(new Map),selectedValues:t([]),getPath:()=>[]}},x=w({activatable:Boolean,selectable:Boolean,activeStrategy:[String,Function,Object],selectStrategy:[String,Function,Object],openStrategy:[String,Object],opened:null,activated:null,selected:null,mandatory:Boolean},"nested"),A=o=>{const u=t(new Map),w=t(new Map),k=e(o,"opened",o.opened,(e=>new Set(e)),(e=>[...e.values()])),x=a((()=>{if("object"==typeof o.activeStrategy)return o.activeStrategy;if("function"==typeof o.activeStrategy)return o.activeStrategy(o.mandatory);switch(o.activeStrategy){case"leaf":return v(o.mandatory);case"single-leaf":return c(o.mandatory);case"independent":return s(o.mandatory);default:return i(o.mandatory)}})),A=a((()=>{if("object"==typeof o.selectStrategy)return o.selectStrategy;if("function"==typeof o.selectStrategy)return o.selectStrategy(o.mandatory);switch(o.selectStrategy){case"single-leaf":return b(o.mandatory);case"leaf":return h(o.mandatory);case"independent":return y(o.mandatory);case"single-independent":return S(o.mandatory);case"trunk":return g(o.mandatory);default:return f(o.mandatory)}})),G=a((()=>{if("object"==typeof o.openStrategy)return o.openStrategy;switch(o.openStrategy){case"list":return m;case"single":return p;default:return d}})),z=e(o,"activated",o.activated,(e=>x.value.in(e,u.value,w.value)),(e=>x.value.out(e,u.value,w.value))),B=e(o,"selected",o.selected,(e=>A.value.in(e,u.value,w.value)),(e=>A.value.out(e,u.value,w.value)));function F(e){const t=[];let a=e;for(;null!=a;)t.unshift(a),a=w.value.get(a);return t}const I=j("nested"),D=new Set,P={id:l(),root:{opened:k,activatable:n(o,"activatable"),selectable:n(o,"selectable"),activated:z,selected:B,selectedValues:a((()=>{const e=[];for(const[t,a]of B.value.entries())"on"===a&&e.push(t);return e})),register:(e,t,a)=>{if(D.has(e)){const a=F(e).map(String).join(" -> "),n=F(t).concat(e).map(String).join(" -> ");M(`Multiple nodes with the same ID\n\t${a}\n\t${n}`)}else D.add(e),t&&e!==t&&w.value.set(e,t),a&&u.value.set(e,[]),null!=t&&u.value.set(t,[...u.value.get(t)||[],e])},unregister:e=>{D.delete(e),u.value.delete(e);const t=w.value.get(e);if(t){const a=u.value.get(t)??[];u.value.set(t,a.filter((t=>t!==e)))}w.value.delete(e)},open:(e,t,a)=>{I.emit("click:open",{id:e,value:t,path:F(e),event:a});const n=G.value.open({id:e,value:t,opened:new Set(k.value),children:u.value,parents:w.value,event:a});n&&(k.value=n)},openOnSelect:(e,t,a)=>{const n=G.value.select({id:e,value:t,selected:new Map(B.value),opened:new Set(k.value),children:u.value,parents:w.value,event:a});n&&(k.value=n)},select:(e,t,a)=>{I.emit("click:select",{id:e,value:t,path:F(e),event:a});const n=A.value.select({id:e,value:t,selected:new Map(B.value),children:u.value,parents:w.value,event:a});n&&(B.value=n),P.root.openOnSelect(e,t,a)},activate:(e,t,a)=>{if(!o.activatable)return P.root.select(e,!0,a);I.emit("click:activate",{id:e,value:t,path:F(e),event:a});const n=x.value.activate({id:e,value:t,activated:new Set(z.value),children:u.value,parents:w.value,event:a});if(n.size!==z.value.size)z.value=n;else{for(const e of n)if(!z.value.has(e))return void(z.value=n);for(const e of z.value)if(!n.has(e))return void(z.value=n)}},children:u,parents:w,getPath:F}};return r(O,P),P.root},G=(e,t)=>{const n=o(O,k),l=Symbol("nested item"),i=a((()=>void 0!==e.value?e.value:l)),s={...n,id:i,open:(e,t)=>n.root.open(i.value,e,t),openOnSelect:(e,t)=>n.root.openOnSelect(i.value,e,t),isOpen:a((()=>n.root.opened.value.has(i.value))),parent:a((()=>n.root.parents.value.get(i.value))),activate:(e,t)=>n.root.activate(i.value,e,t),isActivated:a((()=>n.root.activated.value.has(u(i.value)))),select:(e,t)=>n.root.select(i.value,e,t),isSelected:a((()=>"on"===n.root.selected.value.get(u(i.value)))),isIndeterminate:a((()=>"indeterminate"===n.root.selected.value.get(u(i.value)))),isLeaf:a((()=>!n.root.children.value.get(i.value))),isGroupActivator:n.isGroupActivator};return t&&r(O,s),s},z=()=>{const e=o(O,k);r(O,{...e,isGroupActivator:!0})};export{O as VNestedSymbol,k as emptyNested,x as makeNestedProps,A as useNested,z as useNestedGroupActivator,G as useNestedItem};
