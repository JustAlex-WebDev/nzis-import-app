import{shallowReactive as n,reactive as t,effectScope as o,getCurrentScope as e,hasInjectionContext as s,getCurrentInstance as a}from"/Users/alexandarvalov/Documents/GitHub/nzis-import-app/node_modules/vue/index.mjs";import{createHooks as i}from"/Users/alexandarvalov/Documents/GitHub/nzis-import-app/node_modules/hookable/dist/index.mjs";import{getContext as r}from"/Users/alexandarvalov/Documents/GitHub/nzis-import-app/node_modules/unctx/dist/index.mjs";import{appId as u}from"../../../../_virtual/virtual_nuxt__Users_alexandarvalov_Documents_GitHub_nzis-import-app_.nuxt_nuxt.config.mjs";function l(n=u){return r(n,{asyncContext:!1})}const c="__nuxt_plugin";function p(s){var a;let r=0;const l={_id:s.id||u||"nuxt-app",_scope:o(),provide:void 0,globalName:"nuxt",versions:{get nuxt(){return"3.16.2"},get vue(){return l.vueApp.version}},payload:n({...(null==(a=s.ssrContext)?void 0:a.payload)||{},data:n({}),state:t({}),once:new Set,_errors:n({})}),static:{data:{}},runWithContext:n=>l._scope.active&&!e()?l._scope.run((()=>x(l,n))):x(l,n),isHydrating:!1,deferHydration(){if(!l.isHydrating)return()=>{};r++;let n=!1;return()=>{if(!n)return n=!0,r--,0===r?(l.isHydrating=!1,l.callHook("app:suspense:resolve")):void 0}},_asyncDataPromises:{},_asyncData:n({}),_payloadRevivers:{},...s};l.payload.serverRendered=!0,l.ssrContext&&(l.payload.path=l.ssrContext.url,l.ssrContext.nuxt=l,l.ssrContext.payload=l.payload,l.ssrContext.config={public:l.ssrContext.runtimeConfig.public,app:l.ssrContext.runtimeConfig.app}),l.hooks=i(),l.hook=l.hooks.hook;{const n=async function(n,t){for(const o of n)await l.runWithContext((()=>o(...t)))};l.hooks.callHook=(t,...o)=>l.hooks.callHookWith(n,t,...o)}l.callHook=l.hooks.callHook,l.provide=(n,t)=>{const o="$"+n;g(l,o,t),g(l.vueApp.config.globalProperties,o,t)},g(l.vueApp,"$nuxt",l),g(l.vueApp.config.globalProperties,"$nuxt",l);const c=s.ssrContext.runtimeConfig;return l.provide("config",c),l}function d(n,t){t.hooks&&n.hooks.addHooks(t.hooks)}async function f(n,t){if("function"==typeof t){const{provide:o}=await n.runWithContext((()=>t(n)))||{};if(o&&"object"==typeof o)for(const t in o)n.provide(t,o[t])}}async function v(n,t){var o,e,s,a;const i=[],r=[],u=[],l=[];let c=0;async function p(o){var e;const s=(null==(e=o.dependsOn)?void 0:e.filter((n=>t.some((t=>t._name===n))&&!i.includes(n))))??[];if(s.length>0)r.push([new Set(s),o]);else{const t=f(n,o).then((async()=>{o._name&&(i.push(o._name),await Promise.all(r.map((async([n,t])=>{n.has(o._name)&&(n.delete(o._name),0===n.size&&(c++,await p(t)))}))))}));o.parallel?u.push(t.catch((n=>l.push(n)))):await t}}for(const f of t)(null==(o=n.ssrContext)?void 0:o.islandContext)&&!1===(null==(e=f.env)?void 0:e.islands)||d(n,f);for(const d of t)(null==(s=n.ssrContext)?void 0:s.islandContext)&&!1===(null==(a=d.env)?void 0:a.islands)||await p(d);if(await Promise.all(u),c)for(let d=0;d<c;d++)await Promise.all(u);if(l.length)throw l[0]}function m(n){if("function"==typeof n)return n;const t=n._name||n.name;return delete n.name,Object.assign(n.setup||(()=>{}),n,{[c]:!0,_name:t})}function x(n,t,o){const e=()=>t(),s=l(n._id);return n.vueApp.runWithContext((()=>s.callAsync(n,e)))}function _(n){var t;let o;return s()&&(o=null==(t=a())?void 0:t.appContext.app.$nuxt),o||(o=l(n).tryUse()),o||null}function h(n){const t=_(n);if(!t)throw new Error("[nuxt] instance unavailable");return t}function y(n){return h().$config}function g(n,t,o){Object.defineProperty(n,t,{get:()=>o})}export{c as NuxtPluginIndicator,f as applyPlugin,v as applyPlugins,x as callWithNuxt,p as createNuxtApp,m as defineNuxtPlugin,l as getNuxtAppCtx,d as registerPluginHooks,_ as tryUseNuxtApp,h as useNuxtApp,y as useRuntimeConfig};
